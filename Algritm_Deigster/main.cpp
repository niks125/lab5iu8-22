/**
@file main.cpp
Алгоритм Дейкстры.поиска кратчайшего пути
*/
#include <locale>
#include <iostream>
#include <conio.h>
#pragma hdrstop
#pragma argsused
 
#define VERTEXES 6  ///Число вершин в графе
 
using namespace std;

int v;
int main()
{
	setlocale(LC_ALL,"Rus");
	system("cls");
   int infinity=1000;                     /// Бесконечность
   int p= VERTEXES;             /// Количество вершин в графе
   int a[VERTEXES][VERTEXES]={ 0,1,0,0,1,3,  /// Матрица смежности графа
                               1,0,5,0,0,1,
                               0,5,0,5,20,1,
                               0,0,5,0,3,2,
                               1,0,20,3,0,10,
                               3,1,1,2,10,0  };
 
   /**
   Будем искать путь из вершины s в вершину g
   */
   int s;                   /// Номер исходной вершины
   int g;                   /// Номер конечной вершины
   std::cout<<"Введите начальной вершины: ";     /// Номер может изменяться от 0 до p-1
   std::cin>>s;
   std::cout<<"Введите конечной вершины: ";
   std::cin>>g;
   /**
   Массив, содержащий единицы и нули для каждой вершины,
   x[i]=0 - еще не найден кратчайший путь в i-ю вершину,
   x[i]=1 - кратчайший путь в i-ю вершину уже найден
   */
   int x[VERTEXES];
   int t[VERTEXES];  ///t[i] - длина кратчайшего пути от вершины s в i
   int h[VERTEXES];  ///h[i] - вершина, предшествующая i-й вершине
                 /// на кратчайшем пути
 
   /** 
   Инициализируем начальные значения массивов
   */
   int u;           /// Счетчик вершин
   for (u=0;u<p;u++)
   {
      t[u]=infinity; ///Сначала все кратчайшие пути из s в i равны бесконечности
      x[u]=0;        /// и нет кратчайшего пути ни для одной вершины
   }
   h[s]=0; /// s - начало пути, поэтому этой вершине ничего не предшествует
   t[s]=0; /// Кратчайший путь из s в s равен 0
   x[s]=1; /// Для вершины s найден кратчайший путь
   v=s;    /// Делаем s текущей вершиной
   
   while(1)
   {
      /// Перебираем все вершины, смежные v, и ищем для них кратчайший путь
      for(u=0;u<p;u++)
      {
         if(a[v][u]==0)continue; /// Вершины u и v несмежные
		 /**
		 Если для вершины u еще не 
		 найден кратчайший путь
		 и новый путь в u короче чем 
		 старый, то
		 */
         if(x[u]==0 && t[u]>t[v]+a[v][u]) 
         {
            t[u]=t[v]+a[v][u];  ///запоминаем более короткую длину пути в
    ///массив t и
            h[u]=v; ///запоминаем, что v->u часть кратчайшего 
    ///пути из s->u
         }
      }
 
      /// Ищем из всех длин некратчайших путей самый короткий
      int w=infinity;  /// Для поиска самого короткого пути
	  /**
	   В конце поиска v - вершина, в которую будет 
	   найден новый кратчайший путь. Она станет 
	   текущей вершиной
	  */
      v=-1;            
      for(u=0;u<p;u++) /// Перебираем все вершины.
      {
		  /**
		   Если для вершины не найден кратчайший 
		   путь и если длина пути в вершину u меньше
		   уже найденной, то
		  */
         if(x[u]==0 && t[u]<w) 
         {
            v=u; /// текущей вершиной становится u-я вершина
            w=t[u];
         }
      }
      if(v==-1)
      {
         std::cout<<"Нет пути из вершины "<<s<<" в вершину "<<g<<"."<<endl;
         break;
      }
      if(v==g) /// Найден кратчайший путь,
      {        /// выводим его
         std::cout<<"Кратчайший путь из вершины "<<s<<" в вершину "<<g<<":";
       u=g;
       while(u!=s)
         {
            std::cout<<" "<<u;
            u=h[u];
         }
         std::cout<<" "<<s<<". Длина пути: "<<t[g];
       break;
      }
      x[v]=1;
   }
   getch();
}